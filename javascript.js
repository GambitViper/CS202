//This function accepts three inputs. 
//The first input is a number that denotes the height (in inches) of a person. 
//The second input is a number that denotes the weight of a person (in pounds). 
//The third input is a string that denotes the sex of a person. The sex is “M” for male and “F” for female. 
//This function returns true if the person is at risk and false if they are not. A person is at risk if

//they are male and have a BMI less than 20.4 or greather than 31.9
//they are female and have a BMI less than 19.4 or greather than 27.6
//Body Mass Index (BMI) is defined as a persons weight (in kilograms) divided by the square of their height (in meters).
function risk( height, weight, sex ) {
    var bmi = (weight * 0.45) / Math.pow(height * 0.025, 2);
    if(sex == "F"){
        return bmi < 19.4 || bmi > 27.6;
    }else if(sex == "M"){
        return bmi < 20.4 || bmi > 31.9;
    }
}
/*
    Test Cases
    risk(71.5, 175.3, 'M') => false
    risk(65.2, 230.5, 'M') => true
    risk(65.2, 110, 'F') => true
*/


//This function accepts a single input. The input is either a number or a String. 
//If it is a number, it is a base-10 number in the interval [1, 10]. 
//If it is a String, it is a case-insensitive roman-numeral in the interval [1, 10]. 
//If the input is a Number, in [1, 10], the function returns the corresponding Roman numeral as a String. 
//If the input is a roman-numeral String in the interval [1, 10], then the function returns the corresponding decimal number. 
//This function returns undefined for all other usages.
function roman( number ){
    var conversions = [ 'I', 'II', 'III', 'IV', 'V',
                        'VI', 'VII', 'VIII', 'IX', 'X'];
    if( number <= 10 ){
        return conversions[number - 1];
    }else {
        for(var i = 0; i < 10; i++){
            if(number.toUpperCase() == conversions[i]){
                return i + 1;
            }
        }
        return undefined;
    }
}
/*
    Test Cases
    roman('VII') => 7
    roman('vIi') => 7
    roman( 9 ) => 'IX'
    roman( 128 ) => undefined
    roman( 'Hello' ) => undefined
    roman( roman ) => undefined
*/

//This function accepts two strings: a string named text and a string name ch. 
//The function must search through the text for all occurrences of ch in text and, 
//for each occurrence of ch, return the character that immediately follows ch in text if such a character exists. 
//The order of the characters in the output string is undefined. The result must be a string that contains no duplicate characters.
function lettersThatFollow( text, ch ){
    var split = text.split(ch);
    var return_string = '';
    for(var i = 1; i < split.length; i++){
        var char = split[i].charAt(0);
        if(return_string.indexOf(char) == -1){
            return_string += char;
        }
    }
    return return_string;
}

//This function takes a list of elements and a propertyName string as input. 
//The function returns a list that is generated by obtaining the property-named value of an input element. 
//If a list element doesn't have a property of the specified name, then its value is given as undefined.
function props( list, propertyName ){
    var found_values = [];
    for(var prop of list){
        found_values.push(prop[propertyName]);
    }
    return found_values;
}

//This function takes two inputs, an item and an optional listType. 
//The function returns a string that converts the item into an HTML list element OR an HTML list item element. 
//If listType is provided, it must be either the string "ol" or the string "ul". 
//If listType is not provided, it defaults to "ul". If item is a list, 
//the result is a string that denotes an HTML list of the correct type where sub-lists are also correctly converted to HTML lists. 
//If item is not a list, the result is a string that denotes an HTML list-item. See examples below for clarification.
function listify( item, listType ){
    var html_list = '';
    if(listType != 'ol'){
        listType = 'ul';
    }
    html_list += '<'+listType+'>';
    for(var i = 0; i < item.length; i++){
        html_list += '<li>'
        if(Array.isArray(item[i])){
            html_list += item[i].shift();
            html_list += listify(item[i], listType);
        }else {
            html_list += item[i];
        }
        html_list += '</li>';
    }
    html_list += '</'+listType+'>';
    return html_list;
}

//This function takes two numeric inputs, price and payment, and returns an object 
//that describes the amount of change received for purchasing items that sum to price dollars. 
//The resulting object will have fields named "twenties", "tens", "ones", "quarters", "dimes", "nickels", and "pennies". 
//Each of these fields will be a non-negative number. 
//The change must be computed such that each of these values is maximized, 
//starting from the largest bill (twenty) and moving downward to pennies. 
//The price is always in dollars and will always be in the range [0, 500]. 
//The payment is always in dollars and will always be in the range [0, 500]. 
//If the payment is less than the price, the payment is returned in change.
function cashier( price, payment ){
        var change = payment - price;
        if(change < 0){
            change = payment;
        }
        var change_obj = { twenties : 0, tens : 0, ones : 0, quarters : 0, dimes : 0, nickels : 0, pennies : 0};
        var vals = [ 20, 10, 1, .25, .10, .05, .01];
        var change_vals = [ 0, 0, 0, 0, 0, 0, 0];
        //Find the change
        for(i = 0; i < vals.length; i++){
            while(change - vals[i] >= 0){
                change_vals[i]++;
                change = Math.round((change - vals[i]) * 100) / 100;
            }
        }
        change_obj.twenties = change_vals[0];
        change_obj.tens = change_vals[1];
        change_obj.ones = change_vals[2];
        change_obj.quarters = change_vals[3];
        change_obj.dimes = change_vals[4];
        change_obj.nickels = change_vals[5];
        change_obj.pennies = change_vals[6];
        return change_obj; 
}

/*
    Test Cases
    cashier( 50.5, 60 ) => { twenties : 0, tens : 0, ones : 9, quarters : 2, dimes : 0, nickels : 0, pennies : 0 }
    cashier( 10.32, 80 ) => { twenties : 3, tens : 0, ones : 9, quarters : 2, dimes : 1, nickels : 1, pennies : 8 }
    cashier( 25.1, 10.75 ) => { twenties : 0, tens : 1, ones : 0, quarter : 3, dimes : 0, nickels : 0, pennies : 0 }
*/

//This function accepts a string (text) and an integer number (n). 
//The function must return a string that has n repetitions of text. 
//If n is non-positive this function must return the empty string.
function repeat( text, n ){
    if(n < 0){
        return "";
    }else {
        var repetition = "";
        for(var i = 0; i < n; i++){
            repetition += text;
        }
        return repetition;
    }
}
/*
    Test Cases
    repeat( "cow", 3 ) => "cowcowcow"
    repeat( "alf", 10 ) => "alfalfalfalfalfalfalfalfalfalf"
    repeat( "repeat", -3 ) => ""
*/

//This function accepts a function of no arguments ( f ) and an integer number ( n ). 
//The function must return a list that contains the results of n executions of f. 
//If n is non-positive this function must return the empty list.
function repeatf( f, n ){
    var list = [];
    for(var i = 0; i < n; i++){
        list.push(f());
    }
    return list;
}
/*
    Test Cases
    repeatf( () => { return "cow"; } , 3 ) => [ "cow", "cow", "cow" ]
    repeatf( function() { return 3; }, 2 ) => [ 3, 3 ]
    repeatf( sequence( 3, 15 ), 3 ) => [ 3, 18, 33 ]
*/

//This function accepts an object (obj) and returns a predicate function. 
//The predicate function accepts a single input and returns true 
//if the input contains all of the key/value properties of obj.
function matchmaker( obj ){
    return function( other ){
        var found_one = false;
        for( var prop in other){
            if(obj[prop] != undefined){
                found_one = true;
                if(other[prop] != obj[prop]){
                    return false;
                }
            }
        }
        return !(typeof(other) != 'object' || !found_one);
    }
}
/*
    Test Cases
    var m = matchmaker( { a : 'b', c : 3 } );
    m( { a : 'b', c : 3, d : true } ) => true
    m( { a : 'b', c : 4, d : true } ) => false
    m( 328 ) => false
*/

//This function accepts two inputs: 
//a list of elements and a function that accepts an element from the list. 
//The result is an object whose properties correspond to the items returned by the partitioner 
//and whose values are lists of elements that generated that property.
function breakup(list, partitioner) {
  var break_obj = {};
  for(var i in list) {
    var item = list[i];
    var partition = partitioner(item);
    if(break_obj[partition] == undefined) {
      break_obj[partition] = [ item ];
    }
    else {
      break_obj[partition].push(item);
    }
  }
  return break_obj;
}
/*
    Test Cases
    breakup( [ 1, 2, 3, 5, 6, 7 ], (x) => { return x % 2 == 0; } ) => { true:[ 2, 6 ], false:[ 1, 3, 5, 7 ] }
    breakup( [ 1.3, 5.1, 1.1, 4.3, 5.5 ], Math.floor ) => { 1:[ 1.3, 1.1 ], 4:[ 4.3 ], 5:[ 5.1, 5.5 ] }
    breakup( [“cat”, “bat”, “rat”, “horse”, “pony”], function(s) { return s.length; } ) => { 3:[“cat”, “bat”, “rat”], 4:[“pony”], 5:[“horse”] }
*/

//This function accepts a list of elements as it’s only input. 
//The method returns ‘true’ if every element in the list is truthy; 
//otherwise it returns the first falsey element.
function eachOne( list ){
    for(var i in list){
        if(Boolean(list[i]) != true){
            return list[i];
        }
    }
    return true;
}
/*
    Test Cases
    eachOne( [ 0, 1, 2, 3 ] ) => 0
    eachOne( [ 1, 2, 3, 4 ] ) => true
    eachOne( [ 'a', [], 3, '', null ] ) => ''
*/

//This function accepts a list of elements and an object known as the query. 
//The method returns a list of all elements that have 
//each of the key/value properties of the query.
function noSql( list, query ){
    var matches = [];
    for(var obj of list){
        console.log(obj);
        var check = matchmaker(obj);
        if(check(query)){
            matches.push(obj);
        }
    }
    return matches;
}
/*
    Test Cases
    var objects = [ { public : true, name : "Lion King" }, { public : true, name : 'Dumbo' }, { public : false, name : 'Lion King' }, { name : 'Xeon', rating : 5 } ];
    noSql( objects, { public:true } ) => [ { public:true, name:'Lion King' }, { public:true, name:'Dumbo'}]
    noSql( objects, { name:'Lion King' } ) => [ { public:true, name:'Lion King' }, { public:false, name:'Lion King'}]
    noSql( objects, { rating:5 } ) => [ { name:'Xeon', rating:5 } ]
    noSql( objects, { public:false, name:'Dumbo' } ) => [ ]
*/

//This function accepts a function ‘f’ as input and creates 
//a version of the function that can only be called one time. 
//Repeated calls to the resulting function will 
//return the value from the original call.
function justOnce( f ){
    var used = false;
    var result;
    return function (){
        if(!used){
            used = true;
            result = f.apply(null, arguments);
        }
        return result;
    }
}
/*
    Test Cases
    var a = justOnce( Math.max );
    a( 3, 12 ) => 12
    a( 51, -2) => 12
    a( 6 ) => 12
    a( ) => 12
    var b = justOnce( function() { return new Date(); } );
    b( ) => “Wed Aug 20 2015 08:28:49 GMT-0500 (CDT)”
    b( ) => “Wed Aug 20 2015 08:28:49 GMT-0500 (CDT)”
    b( 33 ) => “Wed Aug 20 2015 08:28:49 GMT-0500 (CDT)”
    b( “a”, “b”, “c”) => “Wed Aug 20 2015 08:28:49 GMT-0500 (CDT)”
*/